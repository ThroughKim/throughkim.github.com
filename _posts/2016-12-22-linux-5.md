---
layout: post
title: 'Linux 공부 5 - 쉘의 명령어 해석 방법'
author: through.kim
date: 2016-12-22 17:00
tags: [linux, study]
image: '/files/covers/codes.jpg'
---

# 명령어를 쉘이 해석하는 방법
> Shell은 또 하나의 프로그램이고 이 프로그램은 사용자가 입력한 명령어들을 해석하며,일반적으로 4~5가지의 쉘이 주로 사용된다.

### 쉘이 하는 일
 - 쉘의 해석 과정  
  -> 명령행을 단어로 분리  
  -> 앨리어스히스토리 쉘 변수 및 환경변수들을 확장  
  -> 표준 입력과 출력 스트림을 초기
 - 입력한 명령어를 쉘이 파싱하는 방법을 이해해야 진정한 파워유저가 될 수 있다.

### bash의 소개
90년대 초까지 주로 C쉘이나 Bourn쉘을 이용하였다. 이후 무료로 쉽게 구할 수 있고,  더 풍부한 기능을 가진  tcsh과 bash가 주목을 받게 되었다.  

ksh / csh이 제공하지 못하는 bash의 유용한 기능  

 - 60개 이상의 쉘 변수  
 - 원하는 정보를 쉘 프롬프트에 모아놓을 수 있다.  
 - vi와 Emacs의 명령행 편집 기능  

### tcsh의 소개
C쉘가 상당히 유사하지만, 더 많은 기능들이 추가되었고, C쉘의 버그도 상당부분 해결하여 많은 인기를 얻었다.  
명령어의 실행을 다시 한번 확인시켜주는 기능은 아래와 같이 나타난다.  

```bash
$ rm *.c
Do you really want to delete all files? [n/y] n
```

오타도 자동으로 수정해준다.  

```bash
$ who | srot +3n +4
CORRECT>who | sort +3n +4 (y|n|e|a)? y
```

### 명령행 해석
C쉘에 있는 여러가지 치환 매커니즘의 우선순위는 매우 중요하다. 다음은 C쉘이 명령행을 해석할 때의 치환 매커니즘의 순위이다.  

```bash
    1. 히스토리 치환
    2. 단어(특수문자를 포함) 분리
    3. 히스토리 목록 갱신
    4. 단일 인용부호와('') 이중 인용부호("")의 해석
    5. 앨리어스 치환
    6. 표준 입출력의 리다이렉션(즉 >, <, |)
    7. 변수 치환
    8. 명령어 치환
    9. 파일명 확장
```

(Bourn쉘은 히스토리 치환과 앨리어스 치환을 하지 않는다는 점을 제외하면 C쉘과 동일하다.)  
히스토리 치환이 인용부호보다 순위가 앞서기 때문에 감탄문에서의 ! 조차 쉘은 히스토리 치환으로 알고 대치시킨다. 치환을 막기 위해서는 \\!로 입력해주어야 한다.

예를 들어 정확히 이해해 보자.  

```bash
$ ls -l $HOME/* |   grep "Mar 7"        # 홈 디렉토리에서 Mar 7을 포함하고 있는 파일의 정보를 표시
```

1. 여기에는 히스토리 연산이 없으므로 생략
2. 명령행을 빈칸으로 구분된 단어들로 분리한다. 분리된 단어는 ls, -l, $HOME/*, \|, grep, "Mar 7"
3. 쉘은 이 명령행을 히스토리 목록에 넣는다(Bourn은 이 과정이 없다.)
4. "Mar 7"주위에 이중 인용부호가 있음을 인지하고 인용부호 내에서는 와일드카드 확장을 하지 않음을 인지한다.
5. 쉘은 'ls'나 'grep'이 앨리어스가 아닌지 검사한다.
6. 쉘이 '\|'를 보고 파이프를 초기화 하기 위한 작업들을 수행한다.
7. 환경변수 '$HOME'을 보고 이를 해당 값(/Users/username)으로 대치시킨다.
8. 쉘은 역인용부호(\`)를 찾아 명령행에 그 결과를 추가한다.(위의 경우에는 해당없음)
9. 와일드카드를 찾는다. 위의 경우 '*'를 찾아 해당 파일명으로 대치시킨다.
10. 쉘은 'ls'를 실행시키고 'ls'의 결과를 파이프를 통해 'grep'의 입력으로 보내어 'grep'을 실행시킨다.